package org.flowvisor.allocator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import org.flowvisor.classifier.FVClassifier;
import org.flowvisor.events.FVEventLoop;
import org.flowvisor.flows.FlowEntry;
import org.flowvisor.flows.FlowMap;
import org.flowvisor.flows.SliceAction;
import org.flowvisor.log.FVLog;
import org.flowvisor.log.LogLevel;
import org.flowvisor.openflow.protocol.FVMatch;
import org.flowvisor.slicer.FVSlicer;
import org.openflow.protocol.OFMessage;
import org.openflow.protocol.OFType;
import org.openflow.protocol.action.OFAction;

public class Allocator {
	//this records all slicer and classifier
	//each slicer represents a controller
	//while each classifier represents a switch
	ConcurrentHashMap<String, FVSlicer> slicerMap;
	ConcurrentHashMap<String, FVClassifier> classifierMap;
	ConcurrentHashMap<String, String> sliceToClassifierMap;
	ConcurrentHashMap<String, SlicerMessageStats> sliceMsgStats;
	ConcurrentHashMap<String, String> switchSliceMap;
	static Allocator runningInstance = null;
	static FVEventLoop loop;

	static TimerScheduler timer;

	//a stats class
	public class SlicerMessageStats {
		HashMap<OFType, Integer> msgCount;

		public SlicerMessageStats() {
			msgCount = new HashMap<OFType, Integer>();
		}

		public void incMessageCount(OFType type) {
			if(!msgCount.containsKey(type)) {
				msgCount.put(type, new Integer(1));
			} else {
				int curr = msgCount.get(type).intValue();
				msgCount.put(type, new Integer(curr + 1));
			}
		}

		@Override
		public String toString() {
			ArrayList<OFType> keylist = new ArrayList<OFType>(msgCount.keySet());
			String ret = "";
			for(OFType key : keylist) {
				ret += key + ":" + msgCount.get(key) + '\n';
			}
			return ret;
		}

		public int getMessageCount(OFType type) {
			if(!msgCount.containsKey(type))
				return 0;
			else 
				return msgCount.get(type);
		}
		
		public void absorb(SlicerMessageStats sms) {
			HashMap<OFType, Integer> toAbsorb = sms.msgCount;
			Set<OFType> keys = toAbsorb.keySet();
			for(OFType key : keys) {
				if(this.msgCount.containsKey(key)) {
					int curr = this.msgCount.get(key).intValue();
					int add = toAbsorb.get(key).intValue();
					this.msgCount.put(key, new Integer(curr + add));
					FVLog.log(LogLevel.DEBUG, null, "#########adding:" + curr + ":" + add);
				} else {
					this.msgCount.put(key, toAbsorb.get(key));
					FVLog.log(LogLevel.DEBUG, null, "#########putting:" + toAbsorb.get(key));
				}
			}
		}
	}
	
	//////////////////////////////

	public void startTimer() {
		timer = new TimerScheduler();
		new Thread(timer).start();
	}

	public static void createAllocator(FVEventLoop eloop) {
		loop = eloop;
		if(runningInstance == null) {
			runningInstance = new Allocator();
			runningInstance.startTimer();
		}

		FVLog.log(LogLevel.DEBUG, null, "#####Create new Allocator#####");

	}

	private Allocator(){
		this.slicerMap = new ConcurrentHashMap<String, FVSlicer>();
		this.classifierMap = new ConcurrentHashMap<String, FVClassifier>();
		this.sliceToClassifierMap = new ConcurrentHashMap<String, String>();
		this.sliceMsgStats = new ConcurrentHashMap<String, SlicerMessageStats>();
		this.switchSliceMap = new ConcurrentHashMap<String, String>();
		FVLog.log(LogLevel.DEBUG, null, "creating new Allocators");
	}

	public static Allocator getRunningAllocator() {
		return runningInstance;
	}

	public void incMsgCount(FVSlicer slicer, OFMessage msg) {
		
		SlicerMessageStats curSms;
		if(!sliceMsgStats.containsKey(slicer.getName())) {
			//new slice coming in
			curSms = new SlicerMessageStats();
			curSms.incMessageCount(msg.getType());
		} else {
			//adding to an existing slice
			curSms = sliceMsgStats.get(slicer.getName());
			curSms.incMessageCount(msg.getType());
		}
		
		String switchName = slicer.getSwitchName();
		/*
		 * 1st, this is ok because in our model, 1 switch will only be in one slice
		 * 2nd, this is useful because what we want to know is the number of packets 
		 * generated by each *switch*, not each *slicer on the switch*
		 */
		if(!this.switchSliceMap.containsKey(switchName)){
			this.switchSliceMap.put(switchName, slicer.getName());
		} else {
			//this means that, the switch used to be in another slice, 
			//so we need to merge the old one to the new one, and delete the old one
			String oldSliceName = this.switchSliceMap.get(switchName);
			if(oldSliceName.equals(slicer.getName())) {
				//still the same, do nothing
			} else {
				this.switchSliceMap.put(switchName, slicer.getName());
				SlicerMessageStats oldSms = this.sliceMsgStats.remove(oldSliceName);
				curSms.absorb(oldSms);
			}
		}
		sliceMsgStats.put(slicer.getName(), curSms);
	}

	public void addNewSlicer(String name, FVSlicer slicer){
		if(!slicerMap.containsKey(name)) {
			FVLog.log(LogLevel.DEBUG, null, "#####Adding a new slicer " + name + "#####");
			slicerMap.put(name, slicer);
		}
	}

	public void addNewClassifier(String name, FVClassifier classifier){
		if(!classifierMap.containsKey(name)) {
			FVLog.log(LogLevel.DEBUG, null, "#####Adding a new classifier " + name + "#####");
			classifierMap.put(name, classifier);
		}
	}

	public void assignSlicerToClassifier(String slicerName, String classifierId) {
		if(!sliceToClassifierMap.containsKey(slicerName)) {
			FVLog.log(LogLevel.DEBUG, null, "#####Adding a new slicer to classifer entry, s:" +
					slicerName + " c:" + classifierId + "#####");
			sliceToClassifierMap.put(slicerName, classifierId);
		}
	}

	public void modifySlicer(FVClassifier fvc, Set<String> newSlices) {
		//####################################
		String ss = "slices are:==========>\n";
		for(String s : newSlices) {
			ss += s + "\n";
			if (s.equals("first")){
				newSlices.remove("first");
				newSlices.add("second");
			}			
		}
		ss += "<==================";
		FVLog.log(LogLevel.NOTE, null, ss);
		//System.out.println(ss);
	}


	private String getSliceMessageStats() {
		String ret = "";
		ArrayList<String> keylist = new ArrayList<String>(sliceMsgStats.keySet());
		for (String key : keylist) {
			ret += "------------------>\n" + key + ":\n" + sliceMsgStats.get(key).toString();
		}
		return ret;
	}

	private void checkAllSlice() {
		ArrayList<String> classifierName = new ArrayList<String>(classifierMap.keySet());
		for (String s : classifierName) {
			FVLog.log(LogLevel.DEBUG, null, "Check Classifier:" + s);
			FVClassifier classifier = classifierMap.get(s);
			if (classifier.getSwitchInfo() == null) {
				FVLog.log(LogLevel.DEBUG, null, "Classifier " + classifier.getDPID() + " does not have switch info");
			} else {
				FVLog.log(LogLevel.DEBUG, null, "Classifier " + classifier.getDPID() + " flowmap change");
				/////////////////////////
				FlowMap fm = classifier.getSwitchFlowMap();
				SliceAction sliceAction;
				FVMatch match = new FVMatch();
				match.setWildcards(FVMatch.OFPFW_ALL);
				ArrayList<FlowEntry> entries = new ArrayList<FlowEntry>(fm.matches(classifier.getSwitchInfo().getDatapathId(), match));
				for (FlowEntry entry : entries) {
					for (OFAction ofAction : entry.getActionsList()) {
						sliceAction = (SliceAction) ofAction;
						if(sliceAction.getSliceName().equals("first")) {
							sliceAction.setSliceName("second");
							FVLog.log(LogLevel.DEBUG, null, "######change slice!!!#######");
						}
					}
				}
				classifier.flowMapChanged(fm);
				/////////////////////////
				//classifier.flowMapChanged(null);
			}
		}
	}

	class TimerScheduler implements Runnable {

		@Override
		public void run() {
			int count = 1;
			try {
				while(true) {
					Thread.sleep(5000);
					FVLog.log(LogLevel.DEBUG, null, "#####Timer Scheduler Waked Up " + (count++) + "#####");
					FVLog.log(LogLevel.DEBUG, null, getSliceMessageStats());					FVLog.log(LogLevel.DEBUG, null, "#####Check Slices#####");
					checkAllSlice();
				}
			} catch (InterruptedException e) {
				e.printStackTrace();
				FVLog.log(LogLevel.DEBUG, null, "#####Allocator Interrupted#####");
			}
		}
	}

}
